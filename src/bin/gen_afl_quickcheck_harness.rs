use std::fmt::Write;
use std::io;
use std::io::Read;
use syn;
use syn::{visit::Visit};
use syn::{FnArg, FnDecl, Ident, Type};
use syn::token::{Unsafe, Async};
use quote::quote;
use auto_fuzz_test::FnVisitor;

fn main() -> io::Result<()> {
    let mut code = String::new();
    let stdin = io::stdin();
    stdin.lock().read_to_string(&mut code)?;

    let syntax_tree: syn::File = syn::parse_str(&code).expect("Failed to parse input. Is it Rust code?");
    // function print_a_test doesn't care about some of the parameters, so we throw them away here
    let callback = |this: Option<&Type>, ident: &Ident, decl: &FnDecl, unsafety: &Option<Unsafe>, asyncness: &Option<Async>| {
        // Unsafe functions cannot have fuzzing harnesses generated automatically,
        // since it's valid for them to crash for some inputs.
        // Async functions are simply not supported for now.
        if unsafety.is_none() && asyncness.is_none() {
            let mut fn_inv = String::new();
            write_fn_invocation(&mut fn_inv, this, ident, decl).unwrap();
            print!("{}", fn_inv);
        }
    };

    // split the template around where the generated functions go
    let (prefix, suffix) = {
        let mut template_split = FUZZING_HARNESS_TEMPLATE.split("{0}");
        (template_split.next().unwrap(), template_split.next().expect("need '{0}' in template"))
    };

    // print everything in sequence
    print!("{}", prefix);
    FnVisitor{callback: Box::new(callback)}.visit_file(&syntax_tree);
    print!("{}", suffix);

    Ok(())
}

fn write_fn_invocation(mut result: &mut Write, this: Option<&Type>, ident: &Ident, decl: &FnDecl) -> Result<(), std::fmt::Error> {
    // print creation of variables
    writeln!(&mut result, "    // create input data for specific function from random bytes")?;
    if let Some(self_type) = &this {
        writeln!(&mut result, "    let fuzz_self = {}::arbitrary(&mut read_rng);", quote!(#self_type))?;
    }
    let mut arg_numbers: Vec<usize> = Vec::new();
    for (num, a) in decl.inputs.iter().enumerate() {
        if let FnArg::Captured(a) = a {
            let pat = &a.pat;
            let arg_type = &a.ty;
            writeln!(&mut result, "    let fuzz_arg_{} = {}::arbitrary(&mut read_rng); // {}", num, quote!(#arg_type), quote!(#pat))?;
            arg_numbers.push(num);
        }
    };
    // print actual invocation of the function
    write!(&mut result, "\n    // invoke function\n    ")?;
    if this.is_some() {
        write!(&mut result, "fuzz_self.")?;
    }
    write!(&mut result, "{}(", ident)?;
    let mut is_first_argument = true;
    for arg_num in arg_numbers {
        if ! is_first_argument {write!(&mut result, ",")?};
        is_first_argument = false;
        write!(&mut result, "fuzz_arg_{}", arg_num)?;
    }
    writeln!(&mut result, ");")?;

    Ok(())
}

const FUZZING_HARNESS_TEMPLATE: &str = "// Autogenerated fuzzing harness. Ignores panics.
extern crate rand;
extern crate quickcheck;

use rand;
use std::io::prelude::*;
use quickcheck::{Arbitrary};

// suppress ASAN false positives
const ASAN_DEFAULT_OPTIONS: &'static [u8] = b\"allocator_may_return_null=1,detect_odr_violation=1\0\";
#[no_mangle]
pub extern \"C\" fn __asan_default_options() -> *const u8 {
    ASAN_DEFAULT_OPTIONS as *const [u8] as *const u8
}

fn main() -> std::result::Result<(), std::io::Error> {
    // read fuzzer input from stdin
    let mut raw_input = vec![];
    std::io::stdin().read_to_end(&mut raw_input)?;

    // input preparation for QuickCheck, not specific to the fuzzed function
    let input_cursor = std::io::Cursor::new(raw_input);
    let read_rng = rand::rngs::adapter::ReadRng::new(input_cursor);
    let mut read_rng = quickcheck::StdGen::new(read_rng, std::usize::MAX);

{0}

    Ok(())
}
";
